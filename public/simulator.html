<html>
<script>

var coordinates = [];

var websocket;
var reader = new FileReader();

function verticalPixels(x,y) {
  coordinates.push(
    x + 1, y + 2 * 1.5,
    x + 1, y + 3 * 1.5,
    x + 1, y + 4 * 1.5,
    x + 1, y + 5 * 1.5,
    x + 1, y + 6 * 1.5,
    x + 1, y + 7 * 1.5,
    x + 1, y + 8 * 1.5,

    x + 2, y + 9 * 1.5,
    x + 2, y + 8 * 1.5,
    x + 2, y + 7 * 1.5,
    x + 2, y + 6 * 1.5,
    x + 2, y + 5 * 1.5,
    x + 2, y + 4 * 1.5,
    x + 2, y + 3 * 1.5,
    x + 2, y + 2 * 1.5,
    x + 2, y + 1 * 1.5,

    x + 3, y + 2 * 1.5,
    x + 3, y + 3 * 1.5,
    x + 3, y + 4 * 1.5,
    x + 3, y + 5 * 1.5,
    x + 3, y + 6 * 1.5,
    x + 3, y + 7 * 1.5,
    x + 3, y + 8 * 1.5
  );
}

function horizontalPixels(x,y) {
  coordinates.push(
    x + 2 * 1.5, y + 1,
    x + 3 * 1.5, y + 1,
    x + 4 * 1.5, y + 1,
    x + 5 * 1.5, y + 1,
    x + 6 * 1.5, y + 1,
    x + 7 * 1.5, y + 1,
    x + 8 * 1.5, y + 1,

    x + 9 * 1.5, y + 2,
    x + 8 * 1.5, y + 2,
    x + 7 * 1.5, y + 2,
    x + 6 * 1.5, y + 2,
    x + 5 * 1.5, y + 2,
    x + 4 * 1.5, y + 2,
    x + 3 * 1.5, y + 2,
    x + 2 * 1.5, y + 2,
    x + 1 * 1.5, y + 2,

    x + 2 * 1.5, y + 3,
    x + 3 * 1.5, y + 3,
    x + 4 * 1.5, y + 3,
    x + 5 * 1.5, y + 3,
    x + 6 * 1.5, y + 3,
    x + 7 * 1.5, y + 3,
    x + 8 * 1.5, y + 3
  );
}

verticalPixels(1, 4);
verticalPixels(1, 19);

horizontalPixels(7.5, 2);
verticalPixels(20, 4);
verticalPixels(20, 19);
horizontalPixels(7.5, 17);
verticalPixels(6, 19);
verticalPixels(6, 4);
horizontalPixels(7.5, 32);

horizontalPixels(26.5, 2);
verticalPixels(39, 4);
verticalPixels(39, 19);
horizontalPixels(26.5, 17);
verticalPixels(25, 19);
verticalPixels(25, 4);
horizontalPixels(26.5, 32);

var leftColors = [];
var rightColors = [];

for(i = 0; i < 368; i++) {
  leftColors.push(255,0,200);
  rightColors.push(0,200,255);
}

var gl;
var program;
var canvas;

function processOpc(message) {
  var channel = message[0];
  var command = message[1];
  var length = message[2] * 256 + message[3];
  var colors = [];
  for(var i = 0; i < length; i++) {
    colors.push(message[4 + i]);
  }
  //console.log(colors);
  if(channel == 0) {
    leftColors = colors;
  } else {
    rightColors = colors;
  }
}
reader.onload = function() {
    processOpc(new Uint8Array(reader.result));
}

function begin() {
  canvas = document.getElementById("glcanvas");
  gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  var vertex_shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertex_shader, document.getElementById('vertex-shader').text);
  gl.compileShader(vertex_shader);
  var success = gl.getShaderParameter(vertex_shader, gl.COMPILE_STATUS);
  if (!success) {
    console.log(gl.getShaderInfoLog(vertex_shader));
  }

  var fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragment_shader, document.getElementById('fragment-shader').text);
  gl.compileShader(fragment_shader);
  var success = gl.getShaderParameter(fragment_shader, gl.COMPILE_STATUS);
  if (!success) {
    console.log(gl.getShaderInfoLog(fragment_shader));
  }

  program = gl.createProgram();
  gl.attachShader(program, vertex_shader);
  gl.attachShader(program, fragment_shader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!success) {
    console.log(gl.getProgramInfoLog(program));
  }

  gl.useProgram(program);

  var positions = [
    0, 0, 1, 1, 0, 1,
    0, 0, 1, 1, 1, 0,
  ];
  var positionAttribute = gl.getAttribLocation(program, "position");
  var positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(positionAttribute);
  gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);

  draw();
  connect();
}

function connect() {
  if( websocket && websocket.readyState <= 2) {
    setTimeout(connect, 2000);
    return;
  }
  websocket = new WebSocket("ws://localhost:8099/");

  websocket.onmessage = function(msg) {
    reader.readAsArrayBuffer(msg.data);
  };
  setTimeout(connect, 2000);
}

function draw() {
  gl.uniform2fv(
    gl.getUniformLocation(program, "coordinates"),
    coordinates
  );

  gl.uniform3fv(
    gl.getUniformLocation(program, "colors"),
    leftColors
  );

  gl.viewport(0, 0, 490, 490);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  gl.uniform3fv(
    gl.getUniformLocation(program, "colors"),
    rightColors
  );

  gl.viewport(50 + canvas.width / 2, 0, 490, 490);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  setTimeout(draw, 1000 / 20);
}

</script>
<script id="vertex-shader" type="x-shader/x-vertex">
  precision highp float;
  attribute vec4 position;

  varying vec2 pos;

  void main() {
    pos = vec2(position.x, (1. - position.y) );
    gl_Position = position * 2. - 1.;
  }
</script>
<script id="fragment-shader" type="x-shader/x-fragment">
  precision highp float;
  varying vec2 pos;
  uniform vec2 coordinates[368];
  uniform vec3 colors[368];

  const float nearx = 0.014;
  const float neary = 0.014;

  void main() {
    float dist = 0.;
    for(int i = 0; i<368; i++) {
      vec2 coord = coordinates[i] / 47.;
      if(abs(pos.x - coord.x) < nearx && abs(pos.y - coord.y) < neary) {
        dist = distance(pos, coord) * 60.;
        float strength = (colors[i].r + colors[i].g + colors[i].b) / 3. / 255.;
        float size = max(0., 1. - dist) * (0.7 + strength);
        gl_FragColor.rgb = max(gl_FragColor.rgb, size * colors[i] / 255.);
        gl_FragColor.a = 1.;
      } else {
        //gl_FragColor.r = pos.x;
        //gl_FragColor.b = pos.y;
      }
    }
  }
</script>
<style>
  body {
    background-color: black;
    text-align: center;
  }
  canvas {
    width: 100%;
    margin: auto;
    position: absolute;
    top: 0; bottom: 0; left: 0; right: 0;
  }
</style>
<body onload="begin()">
  <canvas id="glcanvas" width=1000 height=500></canvas>
</body>
</html>
